---
title: "SFINAE in C++: Substitution Failure Is Not An Error"
date: 2021-06-10
author: Jan Wilczek
layout: post
permalink: /sfinae-substitution-failure-is-not-an-error/
# background: /wp-content/uploads/2020/04/thumbnail.png
categories:
  - C/C++
tags:
  - C
  - Cpp
discussion_id: 2021-06-10-sfinae
---
*Substitution failure is not an error*: what is it and how to use it?

# How is a function to be called picked?

In C++, when we call a function the compiler finds all viable declarations of a called function and picks the best one (the most fitting one) according to a set of very precise rules. They are called *function overload resolution rules*, because declaring more than 1 function with the same but different argument types is called *function overloading*.

On a very high level we can view the overload resolution as a two-step process:
1. Find all overloads of the called function that could viably be called with the given set of arguments.
1. Pick the best one or issue an error if it's not possible (e.g., because of an ambiguity).

Consider the following example:

```cpp
#include <iostream>

void add(double d)
{
    std::cout << "add(double)" << std::endl;
} 

int main()
{
    add(1);     // Calls add(double)
    add(1.0);   // Calls add(double)
}
```
This outputs
```bash
add(double)
add(double)
```

The compiler looked for all possible definitions of the function `add()` and found just one. Since an `int` can be cast to a `double` without losing precision, thus `add(double)` is called and `1` cast to `1.0` without even issuing a warning.

What if we create a specialized version of `add()` for `int`s?
```cpp
#include <iostream>

void add(int i)
{
    std::cout << "add(int)" << std::endl;
}

void add(double d)
{
    std::cout << "add(double)" << std::endl;
} 

int main()
{
    add(1);     // Calls add(int)
    add(1.0);   // Calls add(double)
}
```
This outputs
```
add(int)
add(double)
```

As we can see, the compiler prefers a more specialized version if one is available.

# How is a template function to be called picked?

With function templates, the problem becomes more complicated.

As Bjarne Stroustrup put it: since a function template is a generalization of a function, the rules governing which function will be called in the presence of templates are more general as well.

A function template is not a function on its own. Only when the template argument is explicitly given (by a programmer or a compiler), then the template becomes a function. The process of creating a function out of a function template is called function specialization. Only a specialized function can then take part in the overload resolution.

In the presence of function templates, the overload resolution procedure works as follows:
1. Find a set of function template specializations that will take part in the overload resolution. It is done by analyzing each available function template with the specified name and trying to specialize them for the given set of arguments.
1. If more than one function template can be used, the more specialized (more specific) is used.
1. Perform overload resolution with specialized function templates and regular functions. Prefer the latter.
1. If no match is found or two equally good matches exist, issue an error.

Let's clarify it through an example.

```cpp
#include <iostream>
#include <vector>
#include <assert.h>

template<typename Iter>
typename Iter::value_type sum(Iter b, Iter e)
{
    std::cout << "sum(Iter b, Iter e)" << std::endl;
    typename Iter::value_type out;
    while (b != e)
    {
        out += *b++;
    }
    return out;
}

template<typename T>
T sum(T* b, T* e)
{
    std::cout << "sum(T* b, T* e)" << std::endl;
    T out;
    while (b != e)
    {
        out += *b++;
    }
    return out;
}

int sum(int* b, int* e)
{
    std::cout << "sum(int* b, int* e" << std::endl;
    int out = 0;
    while (b != e)
    {
        out += *b++;
    }
    return out;
}


int main()
{
    std::vector a {1, 2, 3, 4};
    std::vector b {1.0, 2.0, 3.0, 4.0};
    auto c0 = sum(a.begin(), a.end());
    auto c1= sum(b.data(), b.data() + 4);
    auto c2= sum(a.data(), a.data() + 4);
    assert(c0 == c1);
    assert(c1 == c2);
}
```

